import os
from bs4 import BeautifulSoup
from sqlalchemy.orm import Session
from typing import Optional

from backend.app import crud, models, schemas
from backend.app.database import SessionLocal, engine

# User's favorite recipes
FAVORITE_RECIPES = {
    "Weekday Speed & Survival (Mon-Thu)": [
        "Beef with Snow Peas", "Broccolini, Chicken Sausage, and Orzo Skillet", "Chicken and Broccoli (Chinese Takeout Style)",
        "Chicken Milanese", "Chicken Piccata", "Chicken Tinga Tacos", "French Dip Sandwiches", "Garlic Honey Lime Shrimp",
        "Ground Turkey Tacos", "Honey Sriracha Salmon Bowls", "Lamb Keema Matar", "Miso Salmon with Bok Choy",
        "Orecchiette with Sausage and Broccoli Rabe", "Pan Fried Noodles with Shrimp", "Pasta al Limone", "Sesame Chicken",
        "Sheet Pan Pancakes", "Shrimp and Mango Tacos", "Shrimp Scampi with Linguini", "Shrimp with Lobster Sauce (Cantonese)",
        "Thai Basil Noodles", "Turkey Burgers", "Yaki Udon"
    ],
    "Clean & Fuel (Health Focus)": [
        "Arugula Salad with Shaved Parm", "Avocado Kale Caesar Salad", "Baked Cod with Lemon Panko", "Bibimbap",
        "Chana Begoon (Chickpea & Eggplant)", "Chicken Galbi Noodle Salad", "Chicken Shawarma Bowls", "Chicken Souvlaki & Tzatziki",
        "Garlic Sautéed Spinach & Chard", "Greek Salad (Horiatiki)", "Grilled-Pork Banh Mi", "Japanese-Style Trout with Dashi",
        "Massaged Kale & Apple Salad", "Pizza Beans", "Roasted Brussels Sprouts with Balsamic", "Roasted Tomato Basil Soup",
        "Shakshuka", "Shrimp-And-Avocado Summer Rolls", "Smashed Cucumber Salad", "Tuna Poke Bowls", "Tuscan Spaghetti Squash",
        "Vietnamese Grilled Chicken", "Warm Roasted Veggie Salad"
    ],
    "Comfort & Family (Sundays)": [
        "Baked Chicken Parmesan", "Baked Macaroni and Pimento Cheese", "Beef Chow Fun", "Chicken Marsala", "Chicken Tortilla Soup",
        "Chinese Spicy Garlic Eggplant", "Crispy Carnitas", "Enchiladas Suizas", "Glazed Chicken and Broccoli Sheet Pan",
        "Greek-Style Lamb Burgers", "Honey-Glazed Spareribs", "Instant Pot Pulled Pork", "Lemon Ricotta Pasta", "Momma's Healthy Meatloaf",
        "Mushroom Risotto (Pressure Cooker)", "Panang Curry with Chicken", "Pasta with Abruzzi-Style Lamb Sauce",
        "Real Spaghetti Carbonara", "Roasted Corn Chowder with Shrimp", "Sage Brown Butter Sauce Butternut Squash Ravioli",
        "Seafood-Chorizo Tacos", "Spaghetti with Clams and Braised Greens", "Stuffed Shells", "Thai Chicken Curry (Red)",
        "Turkey Sweet Potato Chili"
    ],
    "Projects & Feasts (Weekends)": [
        "Indian Feast: Chicken Tikka Masala + Saag Paneer", "Spanish Feast: Weeknight Paella"
    ],
    "The Thanksgiving Bundle": [
        "Good Eats Roast Turkey", "Corn Bread Dressing", "Sweet & White Potato Gratin", "Spiced Butternut Squash Purée",
        "Cranberry Orange Sauce", "Nana Ruth’s Applesauce"
    ],
    "Breakfast, Desserts & Bar": {
        "Breakfast": ["Banana Oat Greek Yogurt Muffins", "Breakfast Protein Biscuits", "My Favorite Challah", "My Favorite Cornbread", "Nana's Biscuits", "Vanilla Earl Grey Overnight Oats"],
        "Desserts": ["Apple Cider Cream Pie", "Banana Nut Bread", "Chocolate Pie", "Hamantaschen", "Katharine Hepburn’s Brownies", "Mercer Street Carrot Cake", "Mom's Famous Chocolate Cake", "Old-Fashioned Fresh Peach Ice Cream", "Parmigiano Reggiano Cheesecake", "Snickerdoodles"],
        "Bar": ["Elderberry Syrup", "Mango-Rita Green Smoothie", "Vieux Carré"]
    }
}

# Ensure tables are created
models.Base.metadata.create_all(bind=engine)

def get_favorite_recipe_info(recipe_name):
    for category, recipes in FAVORITE_RECIPES.items():
        if isinstance(recipes, list):
            if recipe_name in recipes:
                return {"gold_standard": True, "category": category}
        elif isinstance(recipes, dict):
            for subcategory, sub_recipes in recipes.items():
                if recipe_name in sub_recipes:
                    return {"gold_standard": True, "category": f"{category}/{subcategory}"}
    return {"gold_standard": False, "category": None}

def parse_recipe_html(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        html_content = f.read()

    soup = BeautifulSoup(html_content, 'lxml')

    recipe_data = {}

    # Extract Name
    name_tag = soup.find('h1', itemprop='name', class_='name')
    if name_tag:
        recipe_data['name'] = name_tag.get_text(strip=True)

    # Extract Categories (Tags)
    categories_tag = soup.find('p', itemprop='recipeCategory', class_='categories')
    if categories_tag:
        recipe_data['tags'] = categories_tag.get_text(strip=True)

    # Extract Source
    source_tag = soup.find('a', itemprop='url')
    if source_tag:
        recipe_data['source'] = source_tag.find('span', itemprop='author').get_text(strip=True) if source_tag.find('span', itemprop='author') else source_tag['href']
    
    # Extract Ingredients
    ingredients = []
    ingredients_div = soup.find('div', class_='ingredients text')
    if ingredients_div:
        for p_tag in ingredients_div.find_all('p', class_='line', itemprop='recipeIngredient'):
            ingredient_text = p_tag.get_text(strip=True)
            if not (ingredient_text.endswith(':') and len(ingredient_text.split()) < 5):
                ingredients.append(ingredient_text)
    recipe_data['ingredients'] = ingredients

    # Extract Instructions
    instructions = []
    directions_div = soup.find('div', itemprop='recipeInstructions', class_='directions text')
    if directions_div:
        for p_tag in directions_div.find_all('p', class_='line'):
            instructions.append(p_tag.get_text(strip=True))
    recipe_data['instructions'] = "\n".join(instructions)

    recipe_data['why'] = ""
    recipe_data['notes'] = ""

    return recipe_data

def populate_database(db: Session, recipes_dir: str):
    for filename in os.listdir(recipes_dir):
        if filename.endswith(".html"):
            file_path = os.path.join(recipes_dir, filename)
            print(f"Parsing and adding {filename} to database...")
            data = parse_recipe_html(file_path)

            recipe_name: str = data.get('name', 'Unknown Recipe')

            favorite_info = get_favorite_recipe_info(recipe_name)
            gold_standard = favorite_info['gold_standard']
            favorite_category = favorite_info['category']

            source: Optional[str] = data.get('source')
            existing_tags: Optional[str] = data.get('tags')
            
            all_tags = []
            if existing_tags:
                all_tags.extend([tag.strip() for tag in existing_tags.split(',')])
            if favorite_category and favorite_category not in all_tags:
                all_tags.append(favorite_category)
            
            tags_str = ", ".join(all_tags) if all_tags else None

            instructions: Optional[str] = data.get('instructions')
            why: Optional[str] = data.get('why')
            notes: Optional[str] = data.get('notes')

            # Create Recipe
            recipe_in = schemas.RecipeCreate(
                name=recipe_name,
                source=source,
                tags=tags_str,
                why=why,
                instructions=instructions,
                notes=notes,
                gold_standard=gold_standard
            )
            db_recipe = crud.create_recipe(db=db, recipe=recipe_in)

            # Create Ingredients
            for ingredient_name in data.get('ingredients', []):
                ingredient_in = schemas.IngredientCreate(name=ingredient_name)
                crud.create_ingredient(db=db, ingredient=ingredient_in, recipe_id=db_recipe.id)
            print(f"  Added '{recipe_name}' with {len(data.get('ingredients', []))} ingredients. Gold Standard: {gold_standard}, Category: {favorite_category}")
            print("-" * 30)

if __name__ == "__main__":
    db_session = SessionLocal()
    try:
        populate_database(db=db_session, recipes_dir="My Recipes/Recipes")
        print("Database population complete.")
    except Exception as e:
        print(f"An error occurred: {e}")
        db_session.rollback()
    finally:
        db_session.close()
